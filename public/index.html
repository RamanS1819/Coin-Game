<!DOCTYPE html>
<html>
<body style="background:#333; display:flex; justify-content:center;">
  <canvas id="game" width="600" height="600"
    style="background:#000; border:2px solid #555; margin-top:20px;"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ws = new WebSocket(`ws://${location.host}`);

    let stateBuffer = [];               // Stores last N snapshots

    // IMPORTANT: This must be >= network latency used by the server.
    // Server used LATENCY = 200ms. Use a slightly larger buffer to be safe.
    const RENDER_DELAY = 300;           // Render 300ms in the past

    // Debug helpers (remove or comment out later)
    function dbg(...args) { console.log('[DBG]', ...args); }

    // Receive state updates with timestamps
    ws.onopen = () => dbg('WebSocket OPEN');
    ws.onclose = () => dbg('WebSocket CLOSED');
    ws.onerror = (e) => dbg('WebSocket ERROR', e);

    ws.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);

        // Debug incoming messages
        // dbg('IN:', msg.type, 'ts:', msg.timestamp);

        if (msg.type === 'state') {
          // push snapshot (we keep as-is)
          stateBuffer.push(msg);

          // Keep buffer size reasonable
          if (stateBuffer.length > 60) stateBuffer.shift();
        }

        // Optional: inspect init messages
        if (msg.type === 'init') {
          dbg('Received init:', msg);
        }
      } catch (err) {
        dbg('Failed to parse message', err, e.data);
      }
    };

    // Send movement
    function sendMove(dx, dy) {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'move', dx, dy }));
      }
    }

    // Arrow-key input
    window.addEventListener('keydown', (e) => {
      if (e.key === "ArrowUp") sendMove(0, -1);
      if (e.key === "ArrowDown") sendMove(0, 1);
      if (e.key === "ArrowLeft") sendMove(-1, 0);
      if (e.key === "ArrowRight") sendMove(1, 0);
    });

    // Lerp helper (linear interpolation)
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function render() {
      ctx.clearRect(0, 0, 600, 600);

      const now = Date.now();
      const renderTime = now - RENDER_DELAY;

      // Debug buffer size occasionally
      if (Math.random() < 0.01) {
        dbg('bufferLen', stateBuffer.length, 'renderTime', renderTime);
      }

      // Find two snapshots around renderTime
      let t0 = null, t1 = null;
      for (let i = 0; i < stateBuffer.length - 1; i++) {
        if (
          stateBuffer[i].timestamp <= renderTime &&
          stateBuffer[i+1].timestamp >= renderTime
        ) {
          t0 = stateBuffer[i];
          t1 = stateBuffer[i+1];
          break;
        }
      }

      if (t0 && t1) {
        const total = t1.timestamp - t0.timestamp;
        const current = renderTime - t0.timestamp;
        const alpha = total > 0 ? (current / total) : 0; // guard divide by zero

        // Draw interpolated players
        for (let id in t1.players) {
          const p1 = t1.players[id];  // new snapshot
          const p0 = t0.players[id];  // old snapshot

          // If player didn't exist previously, skip interpolation (we could just draw p1)
          if (!p0) {
            // fallback: draw at current position
            ctx.fillStyle = p1.color || 'white';
            ctx.fillRect(p1.x, p1.y, 20, 20);
            continue;
          }

          const x = lerp(p0.x, p1.x, alpha);
          const y = lerp(p0.y, p1.y, alpha);

          ctx.fillStyle = p1.color || 'white';
          ctx.fillRect(x, y, 20, 20);
        }
      } else {
        // If we don't have a valid pair yet, optionally draw the latest known snapshot (fallback)
        if (stateBuffer.length > 0) {
          const last = stateBuffer[stateBuffer.length - 1];
          if (last && last.players) {
            for (let id in last.players) {
              const p = last.players[id];
              ctx.fillStyle = p.color || 'white';
              ctx.fillRect(p.x, p.y, 20, 20);
            }
          }
        }
      }

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
